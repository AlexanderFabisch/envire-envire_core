#pragma once

#include "GraphTypes.hpp"
namespace envire { namespace core
{
    /** Structure to store the parent and children relation for a vertex in a tree.
     */
    struct VertexRelation
    {
        VertexRelation* parentRelation; /**<can be NULL */
        GraphTraits::vertex_descriptor parent;
        std::unordered_set<GraphTraits::vertex_descriptor> children;
    };

    /**A map that shows the vertex information (parent and children) of the vertices in a tree.
       The key is the vertex descriptor.*/
    using VertexRelationMap = std::unordered_map<GraphTraits::vertex_descriptor, VertexRelation>;
    
    
    class TreeView;
    /**A class that notifies TreeViews about updates */
    struct TreeUpdatePublisher
    {
        virtual ~TreeUpdatePublisher() {}
        /**Unsubscribe the view from the publisher */
        virtual void unsubscribeTreeView(TreeView* view) = 0;
        /**Subscribe the view to the publisher */
        virtual void subscribeTreeView(TreeView* view) = 0;
    };
    
    /** A TreeView is a tree shaped snapshot of the graph structure.
     *  it is generated by traversing the graph in bfs order, starting from a 
     *  root node. The vertex_descriptors used in the graph are pointers to
     *  vertices in the graph and can be used to manipulate the graph.
     */
    class TreeView
    {
    public:
             
        TreeView(GraphTraits::vertex_descriptor root) : root(root) {}
        
        TreeView() : root(GraphTraits::null_vertex()) {}
        
        /**Creates a copy ***without*** retaining the treeUpdated subscribers  */
        TreeView(const TreeView& other)
        {
            *this = other;
        }
        
        /**Creates a copy ***without*** retaining the treeUpdated subscribers  */
        TreeView& operator=(const TreeView& other)
        {
            //this operator has to be here because the default
            //operator= wants to copy treeUpdated, which is is not possible.
            
            //WARNING If you add members to this class, make sure
            //        to copy them!
            publisher = other.publisher;
            tree = other.tree;
            crossEdges = other.crossEdges;
            root = other.root;
            return *this;
        }
        
        TreeView(TreeView&& other) noexcept : tree(std::move(other.tree)),
                                              crossEdges(std::move(other.crossEdges)),
                                              root(std::move(other.root))
        {
            //if the other TreeView was subscribed, unsubscribe it and 
            //subscribe this instead
            if(other.publisher != nullptr)
            {
              other.publisher->unsubscribeTreeView(&other);
              other.publisher->subscribeTreeView(this); //sets this.publisher
              other.publisher = nullptr;
            }
            treeUpdated.swap(other.treeUpdated); //there is no move ctor, therfore swap
        }
        
        
        virtual ~TreeView()
        {
            if(nullptr != publisher)
            {
                //automatic unsubscribe
                publisher->unsubscribeTreeView(this);
                publisher = nullptr;
            }
        }
        
        /**If a publisher is set the TreeView will automatically unsubscribe 
        * from the publisher on destruction. */
        void setPublisher(TreeUpdatePublisher* pub)
        {
            assert(publisher == nullptr);
            publisher = pub;
        }

        bool isRoot(const GraphTraits::vertex_descriptor vd) const
        {
            return vd == root;
        }
        
        /**Removes all content from this TreeView */
        void clear()
        {
            tree.clear();
            crossEdges.clear();
        }
        
        /**Returns true if an edge between a and b exists in @p view.*/
        bool edgeExists(const GraphTraits::vertex_descriptor a, const GraphTraits::vertex_descriptor b) const
        {
            //an edge exists if either a is the parent of b and aChildren contains b
            //or the other way around.
            if(tree.find(a) == tree.end() || tree.find(b) == tree.end())
            {
                return false;
            }
            const VertexRelation& aRelation = tree.at(a);
            const VertexRelation& bRelation = tree.at(b);

            //If we assume that we made no mistake when populating the tree we could just 
            //return (aRelation.parent == b || bRelation.parent == a)
            //but using asserts is always better :D

            //the if will be optimized out if asserts are disabled
            if(aRelation.parent == b) //b is parent of a
            {
              assert(bRelation.children.find(a) != bRelation.children.end());
            }
            else if(bRelation.parent == a) //a is parent of b
            {
              assert(aRelation.children.find(b) != aRelation.children.end());
            }
            return aRelation.parent == b || bRelation.parent == a;
        }
        
        /**visits all vertices in the tree starting at @p node in dfs order.
         * I.e. it first visits node, then all its children.
         * Calls @p f(vertex_descriptor) for each node.*/
        template <class Func>
        void visitDfs(const GraphTraits::vertex_descriptor node, Func f)
        {
          f(node);
          const auto& children = tree[node].children;
          for(const GraphTraits::vertex_descriptor child : children)
          {
            visitDfs(child, f);
          }
        }
        
        /**This signal is invoked whenever the tree is updated by the TransformGraph
        * @note This is only the case if you requested an updating TreeView. 
        *       Otherwise this signal will never be invoked.
        */
        boost::signals2::signal<void ()> treeUpdated;
        
        VertexRelationMap tree;

        /* The edges, that had to be removed to create the tree.
         * I.e. All edges that lead to a vertex that has already been discovered.
         * This does **not** include back-edges. I.e. edges that lead to a vertex that
         * has already been visited.
         * @note The TransformGraph always contains two edges between connected nodes (the edge and the inverse edge)
         *       However only one of them will be in the crossEdges. The other one automatically becomes a back-edge 
         *       and is ignored. */
        std::vector<GraphTraits::edge_descriptor> crossEdges;
        
        /**The root node of this TreeView */
        GraphTraits::vertex_descriptor root;
              
    protected:
        TreeUpdatePublisher* publisher = nullptr;/*< Used for automatic unsubscribing in dtor */
    };
}}